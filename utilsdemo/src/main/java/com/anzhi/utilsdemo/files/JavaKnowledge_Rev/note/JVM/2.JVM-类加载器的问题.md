# JVM-类加载器的问题

考察点：类加载器的类型，以及双亲委派机制的相关点。

## 类加载器

类信息要加载到内存中是通过 JVM 的类加载器完成的。JVM 类加载器的层级分布如下：

![](/Users/azh/Dev_AZH/Java_St/JUC/jvm/src/main/resources/photo/3.类加载器双亲委派模型.png)

不同层级的加载器负责加载的类也不同。

> **启动类加载器(BootStrapClassLoader)：**最顶层的加载器，由 C++ 实现，没有父级，因此在 Java 中通常表示为 null。主要用来加载 JDK 内部的核心类库( `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。

> **扩展类加载器(ExtensionClassLoader)：**主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。

> **应用程序类加载器(AppClassLoader)：**面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

> **自定义类加载器(CustomClassLoader)：**用户自定义类加载实现类的加载，以满足特殊需求的类加载。比如有些加密的 .class 文件需要自定义类加载器对其进行解密然后再加载类。

### 加载原则

检查某个类是否已经加载：顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个Classloader已加载，就视为已加载此类，保证此类所有ClassLoader只加载一次。加载的顺序：加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

聊完 JVM 这些类加载器之后，还需要聊一下 JVM 的双亲委派委派机制。

## 双亲委派机制

> 类加载器有很多种类型，JVM 怎么知道使用那种加载器呢？通过双亲委派机制来决定。

> 双亲委派模型的工作过程是：如果一个类加载器收到了类加载器的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每一个层次的加载器 都是如此。所以，所有的类请求加载都会传送到最顶层的启动类加载器中。只有父类加载器无法完成这个加载请求(它的搜索范围中没有找到需要的类)时。子类加载器才会去尝试自己加载。

### 双亲委派的意义

1. **保证类的优先级：**Java 中的类随着它的类加载器一起具备了一种带有优先级的层级关系；
2. **保证类的唯一性：**不同的类加载器加载相同的类，这两个类的类型也是不一样的；
3. **沙箱安全机制：**防止核心 API库被随意篡改；

### 自定义类加载器的意义

双亲委派机制保证了类的唯一性，但是在实际的业务场景中，当版本进行迭代，需要兼容之前的业务，不同模块针对同一个功能类使用的版本不同，此时双亲委派保证类的唯一性反而成了弊端。因此才需要用户自己定义类加载器。

> 自定义类加载器实现方式：
>
> 1. 重写 findClass 方法；
> 2. 重写 loadClass(注意这里会打破双亲委派的机制，导致 JDK 核心类无法加载，所以需要确定子类的父类加载器是什么。)

## 堆-类加载过程

堆中，类的创建流程如图所示：

![](/Users/azh/Dev_AZH/Java_St/JUC/jvm/src/main/resources/photo/5.创建对象的主要流程.png)

### 类检查：

虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个 符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 new指令对应到语言层面上讲是， new关键词、对象克隆、对象序列化等。

### 分配内存：

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。这个步骤有两个问题:

> 1. 如何划分内存。
>
> 2. 在并发情况下，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。

> 解决办法：
>
> 1. CAS(compare and swap)：虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。
>
> 2. 本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预 先分配一小块内存。通过 `-XX:+UseTLAB`.参数来设定虚拟机是否使用TLAB(JVM会默认开`-XX:+UseTLAB`), `-XX:TLABSize` 指定TLAB大小。

### 初始化

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)， 如果使用TLAB，这一工作过程也 可以提前至TLAB分配时进行。这一 步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问 到这些字段的数据类型所对应的零值。

### 设置对象头

初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。

如图是对象头的组成：

![](/Users/azh/Dev_AZH/Java_St/JUC/jvm/src/main/resources/photo/6.对象头结构.png)

> 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域:
>
> **对象头(Header)、 实例数据(Instance Data) 和对齐填充(Padding)**。

> HotSpot虚 拟机的对象头包括两部分信息：
>
> **第一部分用于存储对象自身的运行时数据，** 如哈'希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、 偏向线程ID、偏向时间戳等。
>
> 对象头的另外一部分 是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

> 为什么要对齐填充：
>
> 1. 提高 CPU 读取效率。HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，对齐填充后可以整数倍读取，减少 I/O 操作。
> 2. 解决缓存行伪共享问题：没有对齐填充时，A线程只想要读取a，但a只占4字节，因此会连带b也会一并读取到缓存行中；而同一时刻B线程只想要读取b，但b只占4字节，因此会连带a也会一并读取到缓存行中；那么这种情况下就会存在伪共享问题，这会导致A和B线程在进行数据操作时会频繁地直接去内存获取最新值，而不是从高速缓存中获取（也就是缓存失效），导致运算速度下降。

> 为什么要压缩指针：
>
> 1. 在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据， 占用较大宽带，同时GC也会承受较大压力。
> 2. 为了减少64位平台下内存的消耗，启用指针压缩功能。
> 3. 在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的压缩编码、解码方式进行优化，使得jvm 只用32位地址就可以支持更大的内 存配置(小于等于32G)。
>
> 注意堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好。

> ### 32位最大支持4G内存，如何实现的
>
> **内存是把8个bit排成1组， 每1组成为1个单位， 大小是1byte(字节）， cpu每一次只能访问1个byte， 而不能单独去访问具体的1个小格子(bit). 1个byte字节就是内存的最小的IO单位。所以计算机的32位表示32个地址，在计算机寻址的时候，每次访问的时是一个字节，即 8 bit, 因此换算过来的话就是 2^32 \* 2^3 =4GB=2^35** 就这样算出了 2^32=4GB。
>
> 指针压缩则是将 8 个字节组成一组。

## 栈内存分配流程

栈内存分配如图所示：

![](/Users/azh/Dev_AZH/Java_St/JUC/jvm/src/main/resources/photo/8.栈中对象内存分配流程.png)

首先总结一下为什么要把对象放入栈中：

> 背景：JVM 回收对象是根据对象有没有被引用来判定的。当对象没有被引用，需要 GC 进行垃圾回收。当对象过多时，会给 GC 带 来压力，进而影响程序性能。
>
> 在这些对象中存在一些临时对象，这些应该随着局部变量一起消亡，而不是要等到 GC 进行垃圾回收；
>
> 解决：JVM 分配的栈内存就具备这一特性，当某一个方法执行完成，它对应的栈也就消亡了，栈内存中的对象也随之消亡，这样就减轻了 GC 压力，因此才需要将这些临时对象存放到栈中；

那么什么样的对象才会放入栈中呢？

> VM 通过**逃逸分析**确定该对象不会被外部访问，如果不会逃逸，那么这种对象就会被存放到栈中(如果对象太大，也是要放入堆中)；

什么是逃逸分析呢？

> 就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参 数传递到其他地方中。
>
> JVM 可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过**标量替换**优先分配在栈上(栈上分配)， JDK7之后默认开启逃逸分析，如果要关闭使用参数(-XX:-DoEscapeAnalysis)。

标量替换是什么？

> JVM **针对逃逸分析过后的对象**，在**确定对象不会被外部引用**，且可以进一步分解的时候，**JVM 不会创建这个对象**，而是将该 对象成员变量分解若干个 被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就 不会因为没有**一大块连续空间导致对象内存不够分配**。开启标 量替换参数(-XX:+EliminateAllocations)，JDK7之后默认开启。

## 堆内存划分

JVM 将堆分为了 新生代、老年代。而新生代进一步被划分为 Eden 区 Survivor 区，这两个区的比例为 8:1; Survivor 区进一步被划分为 Survivor to 区和 Survivor From 区(这两个区的名称是相互转换的)，比例 1:1。

### TLAB-快速分配策略

> 背景：
>
> 由于目前的多数应用都会根据业务创建线程，因此，每个线程分配到的内存大小是比较稳定的(每次对象分配的大小，以及个数)。所以如果能估算每轮 GC 内每个线程使用内存大小，就可以提前给这个线程分配内存空间，这样就能提高分配效率，而这种方案的实现在 JVM 中就是 TLAB(Thread Local Allocate Buffer)。

堆是一个线程共享的区域。因此多线程下为各自对象分配内存空间是不安全的，不安全就需要上锁，但是上锁就会导致性能下降。因此直接在 Eden 区分配内存空间之前，JVM 为每一个线程创建各自的私有缓存空间 TLAB，这样就避免了锁的开销。

当 TLAB 空间使用完了或者 TLAB 无法存放这个对象的时候， 才会使用 CSA 在公共的 Eden 区为对象分配空间(TLAB 包含在 Eden 区中), 这种内存分配方式称为**快速分配策略**。

> 如何计算每个线程使用内存空间的大小？
>
> **EMA（Exponential Moving Average 指数平均数）算法**：EMA 算法的核心在于设置合适的**最小权重**，根据数据表明，**最小权重越大**，变化得越快，受**历史数据影响越小**。根据应用设置合适的**最小权重**，可以让你的期望更加理想。也就意味着线程 TLAB 内存分配空间的愈加稳定。

而提前为线程分配好 TLAB 空间后，也会提高程序运行效率。这也就是程序为什么会运行越来越快的原因。

> UseTLAB
> 说明：是否启用 TLAB，默认是启用的。
>
> 默认：true
>
> 举例：如果想关闭：-XX:-UseTLAB
>
> ZeroTLAB
> 说明：是否将新创建的 TLAB 内的所有字节归零。我们创建一个类的时候，类的 field 是有默认值的，例如 boolean 是 false，int 是 0 等等，实现的方式就是对分配好的内存空间赋 0。设置 ZeroTLAB 为 true 代表在 TLAB 申请好的时候就赋 0，否则会在分配对象并初始化的时候赋 0.讲道理，由于 TLAB 分配的时候会涉及到 Allocation Prefetch 优化 CPU 缓存，在 TLAB 分配好之后立刻更新赋 0 对于 CPU 缓存应该是更友好的，并且，如果 TLAB 没有用满，填充的 dummy object 其实依然是 0 数组，相当于大部分不用改。这么看来，开启应该更好。但是ZeroTLAB 默认还是不开启的。
>
> 默认：false
>
> 举例：-XX:+ZeroTLAB
>
> ResizeTLAB
> 说明：TLAB 是否是可变的，默认为是，也就是会根据线程历史分配数据相关 EMA 计算出每次期望 TLAB 大小并以这个大小为准申请 TLAB。
>
> 默认：true
>
> 举例：如果想关闭：-XX:-ResizeTLAB
>
> TLABSize
> 说明：初始 TLAB 大小。单位是字节
>
> 默认：0， 0 就是不主动设置 TLAB 初始大小，而是通过 JVM 自己计算每一个线程的初始大小
>
> 举例：-XX:TLABSize=65536
>
> MinTLABSize
> 说明：最小 TLAB 大小。单位是字节
>
> 默认：2048
>
> 举例：-XX:TLABSize=4096
>
> TLABAllocationWeight
> 说明： TLAB 初始大小计算和线程数量有关，但是线程是动态创建销毁的。所以需要基于历史线程个数推测接下来的线程个数来计算 TLAB 大小。一般 JVM 内像这种预测函数都采用了 EMA 。这个参数就是 图06 中的最小权重，权重越高，最近的数据占比影响越大。TLAB 重新计算大小是根据分配比例，分配比例也是采用了 EMA 算法，最小权重也是 TLABAllocationWeight
>
> 默认：35
>
> 举例：-XX:TLABAllocationWeight=70
>
> TLABWasteTargetPercent
> 说明：TLAB 的大小计算涉及到了 Eden 区的大小以及可以浪费的比率。TLAB 浪费指的是上面提到的重新申请新的 TLAB 的时候老的 TLAB 没有分配的空间。这个参数其实就是 TLAB 浪费占用 Eden 的百分比，这个参数的作用会在接下来的原理说明内详细说明
>
> 默认：1
>
> 举例：-XX:TLABWasteTargetPercent=10
>
> TLABRefillWasteFraction
> 说明： 初始最大浪费空间限制计算参数，初始最大浪费空间限制 = 当前期望 TLAB 大小 / TLABRefillWasteFraction
>
> 默认：64
>
> 举例：-XX:TLABRefillWasteFraction=32
>
> TLABWasteIncrement
> 说明： 最大浪费空间限制并不是不变的，在发生 TLAB 缓慢分配的时候（也就是当前 TLAB 空间不足以分配的时候），会增加最大浪费空间限制。这个参数就是 TLAB 缓慢分配时允许的 TLAB 浪费增量。单位不是字节，而是 MarkWord 个数，也就是 Java 堆的内存最小单元，64 位虚拟机的情况下，MarkWord 大小为 3 字节。
>
> 默认：4
>

### Eden 区

大部分的对象刚创建的时候是要存放到 Eden 区的，Eden 区放满以后会触发一次 minor gc，大部分对象会被回收掉，剩余存活的对象会被转移到 Survivor 区； 当 Eden 再次被放满的时候，还会触发 minor gc，此时 JVM 不仅仅会回收掉 Eden 区的垃圾对象，还会回收 Survivor 区的对象，将存活的对象放入另一块 Survivor 区中。

在新生代的中存放的对象都具有"朝生夕死"的特点，生命周期较短，每进行一次 Minor GC 后，剩余存活的对象是非常少的。因此 JVM 才会将 Eden 区 设置的尽量大，Survivor 较小。JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有 变化可以设置参数-XX:-UseAdaptiveSizePolicy。

---

**以下相关问题可以归纳为什么情况下，对象会进入老年代？**

### 大对象

大对象指那种需要大量连续空间的对象(比如字符串，数组)。 JVM 参数可以通过 -XX:PretenureSizeThreshold 设置大对象，如果对象的大小超过设置的阈值，对象会被直接放入老年代中。这个参数只在 Serial 和 ParNew 两个收集器下有效。

设置大对象的原因是因为，如果程序中存在很多大对象，那么就可以直接设置 JVM 参数值，让其进入老年代，而不需要在年轻代来回移动，从而降低性能。

### 在 Eden 区的对象什么时候进入老年代

在 Eden 区放满对象后，会触发一次 Minor GC，此时会清空 Eden 区，将对象移动到 Survivor 区，如果存放不下，才会移动到老年代，那么如果经过 多次 GC 后，对象依然存活，那么这些对象应该被存放到老年代中，而不是 Eden区，因为Eden区存放的都是"朝生夕死"的对象。那么如何判断这些对象什 么时候该进入老年代呢？

为了实现这个目标，JVM 给每一个对象设定了年龄 Age(计数器)，如果对象在 Eden 区出生，在经历过了一次 Minor GC 后仍然存活，且可以被 Survivor 区接纳，就将对象年龄设定为 1，此后每经历过一次 Minor GC，年龄就加 1，当他的年龄增加到一定程度的时候(默认 15 岁， CMS默认16，不同的垃圾 收集器，略有不同)，对象就会被移动到老年代。对象晋升老年代的阈值可以通过参数`-XX:MaxTenuringThreshold` 来判断。

### 对象动态年龄判断(JDK1.8)

在 Survivor 区也有针对对象年龄的优化：当存放 Survivor 区中的对象总大小超过了 Survivor 区大小的 50%(可以通过-XX:TargetSurvivorRatio可以指定)， 那么此时在加完某一个对象的大小后，刚好大于等于 Survivor 空间的 50%，那么就以这个对象的年龄为界限，大于等于这个对象年龄的都要进入老年代。 举个例子：A对象age=1，占 Survivor 空间大小21%，B对象age=2 占 30%，C对象age=13， 此时 A+B 的大小超过 Survivor 区大小的 50%，此时 B、C 就因该直接进入老年代。

### 老年代空间分配担保机制

Eden、和 Survivor 存放不了对象都要放入老年代，那么如果老年代的空间不够用了怎么办呢？此时老年代就需要提前 Full GC，以此来腾出更多的空间， 保证可以容纳年轻代转移过来的对象。但是如果够用，就不用进行 Full GC 了，因此产生了老年代空间分配担保机制。

通过参数“-XX:HandlePromotionFailure”(jdk1.8默认就设置了，从jdk 1.6 之后这个参数就不起作用了)设置。这个参数设置以后，在 Eden 区进行 Minor GC 后，老年代会用自己的空间大小与前几次的Minor GC 后进入老年代对象大小的平均值进行比较。在 1.6 之后，规则变成只要老年代的连续空间 大于新生代总对象大小或者历次晋升的平局大小，就会进行 Full GC，否则进行一次 Full GC。

