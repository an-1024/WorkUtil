# Redis
## 问：Redis 有几种基础数据类型?
## 答：
> String(字符串)、hash(散列表)、list(列表)、Set(集合)、zset(有序集合)
## 问：那了解这些数据类型的底层实现吗？
## 答
> Redis 底层基础数据结构有 6 种  
> 1、简单动态字符串（SDS）  
> 2、链表  
> 3、字典  
> 4、跳跃表  
> 5、整数集合  
> 6、压缩列表
## 问：Redis 的 String 类型底层实现是什么，为什么要自己实现？
> String：Redis 自己实现了一种动态字符串 SDS，其构成是：  
> len：记录已经使用的字节数  
> free：表示剩余可使用的空间   
> buf：用于保存字符串的地方
---
> 相比与 C 的字符串实现，Redis 自己实现 SDS 具有以下特点：  
> 1、常数复杂度获取字符串长度，可以直接通过 len 获取字符串长度  
> 2、杜绝缓冲区溢出，减少修改字符串时带来的内存重分配次数：SDS实现了空间预分配和惰性空间释放两种优化的空间分配策略，解决了字符串拼接和截取的空间问题；  
> 3、二进制安全：相比与 C 语言字符串中不能出现空格等特殊字符，SDS 的 API 都会将数据以二进制的方式尽心存储，也就不存在对数据的限制，SDS 通过 len 属性判断字符串是否结束。  

## 问：了解 Redis 持久化吗，AOF 和 RDB 有什么区别
## 答：
> Redis 持久分为两种 AOF 和 RDB，在 Redis 4.0 之后新增了混合持久化的方式，集成了 RDB 和 AOF 的优点
> RDB 快照：顾名思义就是将 Redis 某一刻的数据进行备份写入磁盘中，以二进制的形式存储到一个dump.rdb文件中。在 redis.conf 文件中提供了 save 参数来配置多长时间进行一次备份。该机制存在以下三个问题：  
> 1、数据丢失问题：在备份的那一刻，Redis 宕机，这会造成这一段时间的数据丢失；比如 save 60 1000，在这 60s 1000 个被修改的数据就会丢失；  
> 2、时点性问题：写入数据需要时间，比如 8点开始写入数据，需要4s写入，那么最终存入磁盘的数据是哪一刻的呢？  
> 3、效率问题：Redis 执行持久化的过程中是无法执行其他命令操作的，会阻塞；  
> 针对2、3 问题，Redis 采用了写时复制技术，bgsave 命令的实现就是从父进程中 fork 一个子进程。如果父进程是读数据，因为子进程共享父进程数据，没有影响。如果父进程是写数据，那么父进程会将那一刻的数据复制一份，在新的内存区域进行修改，子进程仍指向原来的区域进行持久化。因此持久化数据的时间就是 fork 子进程的那一刻，而且是异步进行，不会阻塞主进程。  
> 数据丢失的问题 Redis 通过 AOF 来解决。  
---
> AOF(增量备份)：AOF 是为了解决 RDB 数据丢失的问题。AOF 会将每一条修改命令以文本的形式追加到appendonly.aof文件中。Redis 提供了三种持持久化的配置：  
> 1、appendfsync always # 每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。  
> 2、appendfsync everysec # 每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据。  
> 3、appendfsync no # 从不 fsync ，将数据同步时机交给操作系统来处理。更快，也更不安全的选择。
---
> 所以在使用 RDB 进行数据恢复时，可以直接读取文件进行恢复，AOF 则需要将全量的日志执行一遍恢复。当 AOF 文件很大的时候，这个数据恢复时间是很长的，因此有了 4.0 混合持久化。  
> 在开启混合持久化后，父进程 fork 出的子进程会将当前进程的全量数据以 RDB 形式写入 AOF 文件，然后将写入缓冲区的增量命令以追加的方式写入 AOF 文件。 写入完成后通知父进程用新的 AOF 文件替换旧的 AOF 文件。 

## 问：前面说到了 AOF，AOF 为什么采用先写日志后写磁盘的操作？那后写日志会有什么问题？
## 答：
> 这个主要是由于 Redis 在写入日志之前，不对命令进行语法检查，所以只记录执行成功的命令，避免出现记录错误命令的情况，而且在命令执行后再写日志不会阻塞当前的写操作;  
> 写后日志会导致以下两个问题：  
> 数据可能会丢失：如果 Redis 刚执行完命令，此时发生故障宕机，会导致这条命令存在丢失的风险。  
> 可能阻塞其他操作：AOF 日志其实也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。