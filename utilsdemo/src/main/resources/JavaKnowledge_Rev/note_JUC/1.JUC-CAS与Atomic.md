# CAS 定义

CAS(Compare and Swap 比较并交换)：它是一条 CPU 并发原语，用于判断内存中某个值是否为预期值，如果是则更改为新的值，这个过程是原子的。

> 作用：解决多线程并行情况下使用锁造成性能损耗的一种机制。
>
> 实现逻辑：CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。

# CAS-Unsafe 类

Unsafe 类中封装了 native 方法。具体在 JVM 层的实现是 Atomic::cmpxchg 方法。这里以 AMD 的实现举例：

```c++
#define LOCK_IF_MP(mp) "cmp $0, " #mp "; je 1f; lock; 1: "

inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) {
  int mp = os::is_MP();
  __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgl %1,(%3)"
                    : "=a" (exchange_value)
                    : "r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp)
                    : "cc", "memory");
  return exchange_value;
}
```

> volatile 在 C、C++ 中表示不允许编译器进行优化。避免编译器对指令进行重排造成不可知的问题，以及保证每次修改变量完成之后必须将更新后的值刷入内存中。
>
> LOCK_IF_MP(mp): 宏定义了 CPU 的操作指令，注意它的说明：如果当前系统为多核 CPU 的时候，需要在 MP 机器上为指令添加**锁**（lock）前缀，保证线程安全。
>
> 看到网上的说法，这里上锁的是北桥信号，不是总线。

如图可以很好的解释为什么要在 cmpxchg 命令加 lock 锁前缀。

![](/Users/azh/Dev_AZH/Java_St/JUC/lockThread/src/main/resources/photo/3.cmpxchg指令非原子操作.png)

在高并发下，就会存在如上图这样一个场景，A线程在更新0所在内存地址值的时候，B线程将0修改为2，接着线程 A 开始写入，发现与原来的旧值不等，结果将原来的旧值 0 又写入内存。因此在多核下才会在  cmpxchg 命令前加一个 lock 前缀，进行加锁操作来保证线程安全。

所以 CAS 在内核层终归还是通过加锁来保证了线程安全。无锁只是表现在用户层面。

# CAS 带来的问题

## ABA问题

![](/Users/azh/Dev_AZH/Java_St/JUC/lockThread/src/main/resources/photo/4.CAS-ABA问题.png)

> 无法感知变量从A变为B，再从B变为A过程。
>
> 解决：添加版本号。

## 加载时间过长的问题

高并发下，自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。

> 解决：
>
> 1. 从自旋次数入手，破坏循环，限定循环次数；
> 2. 使用类似ConcurrentHashMap的方法。当多个线程竞争时，将粒度变小，将一个变量拆分为多个变量，达到多个线程访问多个资源的效果，最后再调用sum把它合起来，能降低CPU消耗。比如 LongAdder。将变量值分散放到 Cell[] 数组中，各个线程只需要操作自己对应槽中的值，如果要获取正真的值，最终求和即可。这个就是分散热点的思想。
> 3. 利用 JVM 的 pause 指令，通过让渡 CPU 资源给其他线程提升整体运算效率。另一方面，由于线程的让渡，避免了竞争，减少了对共享内存的访问，提升其他线程的效率。

# CAS 的缺点

 **CAS只能单变量对于一个共享变量，可以使用CAS方式来保证原子操作，但是当多个共享变量时，那就无法使用CAS来保证原子性**。JDK1.5开始，提供了AtomicReference类来保证引用对象之前的原子性，就可以把多个变量放在一个对象里来进行CAS操作。

