# JVM 内存模型

了解 JVM 内存分布吗，介绍一下。

JVM 运行时会将自己管理的内存分为若干个区域，如图所示：

![](/Users/azh/Dev_AZH/Java_St/JUC/jvm/src/main/resources/photo/4.JVM内存结构.png)

## 线程共享区域与线程非共享区域

可以从线程的角度对这些区域进行区分。如：可以将 JVM 的运行时数据区分为两大类：

> 线程共享区域，和线程非共享区域。

### 线程共享区域

线程共享的区域有：堆、方法区；

#### 堆

堆是在 JVM 启动时就会分配的一块内存区域，主要用来存放程序运行期间产生的实例(new 对象)以及数组。因此这块区域也可以称之为”堆内存“；

堆的内存可以是不连续的空间。堆的大小可以固定，也可以通过参数调整。参数如下：

> -Xms20M：设置 JVM启动时的最小值为20M。
>
> -Xmx20M ：设置JVM堆的最大值为20M。
>
> 一般来说会将堆的最小值和最大值调整为一样，这样是为了避免频繁地扩容，从而影响程序性能。

#### 方法区：

方法区具体存放的数据信息包含：用于存储已被虚拟机加载的类型信息(.Class 文件)、常量、静态变量、即时编译器编译后的代码缓存等信息。

和堆一样可以通过参数控制空间大小：

> JDK 1.8 及之后
>
> -XX:MetaspaceSize=N：元空间初始值大小。
>
> -XX:MaxMetaspaceSize=N：元空间最大上限值；不指定。默认 -1，表示无穷大，只受限于物理内存。

方法区在逻辑上是归属于堆的一部分，但是具体的落实却是一块独立的空间。因此方法区属于“非堆内存”。

> 在 JDK 1.7 及之前，方法区的实现是在永久代中(只限于HotSpot虚拟机)实现，这个永久代是在 JVM 管理的内存中单独划分了一块儿空间；
>
> 在 JDK 1. 8 及之后，方法区的实现从 JVM 管理的内存中转移到了物理内存之中，这个空间叫元空间；
>
> 为什么废弃永久代：是因为永久代设置空间大小是很难确定的，比如在某些场景下，动态类比较多的话，容易产生Perm区的oom。而元空间与永久代最大的区别就是元空间使用的是本地内存，只会受到本地物理内存的限制。

### 线程非共享区域

> 线程非共享区域：栈、本地方法栈、程序计数器。

#### 栈(线程栈)

也可以称之为线程栈，存放线程的相关数据。因为程序启动就会有一个主线程开始执行，期间产生的数据就存放到栈内存中。比如： 存储局部变量表、操作栈、动态链接、方法出口，对象指针等。

##### 栈帧

栈帧（Stack [Frame](https://so.csdn.net/so/search?q=Frame&spm=1001.2101.3001.7020)）是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机运行时数据区中的虚拟机栈的栈元素。数据的存储是有栈帧实现的。

每个方法从执行开始到执行结束都对应着一个栈帧的入栈到出栈的过程。

栈帧由局部变量表、操作数栈（Operand Stack）、动态链接（Dynamic Linking）、方法返回地址（Return Address）和一些附加信息（对程序调试提供支持的信息）组成。

> 局部变量：主要存放了编译期明确的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不是针对对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。
>
> 操作数栈：操作数主要作为方法调用的中转站使用，主要用来存放Java方法执行过程中产生的中间计算结果和计算过程中产生的临时变量。
>
> 动态链接：动态链接主要支撑一个Java方法需要调用其他方法的场景。所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在Class 文件的常量池里面。当一个Java方法要调用其他Java方法，需要将常量池中指向方法的符号引用转换为其在内存地址中的直接引用。动态链接作用：其实就是将符号引用转换为调用方法的直接引用。
>
> 方法返回地址：Java方法开始执行后，退出这个方法的方式：正常退出、异常退出。
>
> > 正常退出：执行引擎遇到方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者。 正常退出时调用PC计数器的值可以作为返回地址。
> >
> > 异常退出：在方法执行过程中遇到异常，且异常没有在方法体内得到处理，返回地址要交给异常处理表来决定如何处理。
>
> 方法退出之后，都需要返回到方法被调用的原始位置，程序才能继续执行。
>
> 栈的优缺点:
>
> > 栈帧内数据共享：一个栈帧中内存数据共享，不同栈帧之间数据不共享，这样可以减少内存消耗存储速度：栈帧存取数据快，仅次于寄存器。
> >
> > 编译的时候就分配好了内存，运行过程中不需要申请内存大小，节约时间成本。
> >
> >  栈是机器提供的数据结构，计算机会分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，效率高。
> >
> > 相比较堆来说，访问效率高。
>
> 栈的缺点：
>
> > 灵活性差：栈在运行过程中，不能动态的去申请内存、程序可能会报错。

通过参数可以控制栈的大小：

> -Xss2m：设置栈的大小为 2m。

#### 本地方法栈

一个Native Method就是一个Java调用非Java代码的接囗。

#### 程序计数器

**管理下一步要执行的指令的存储器地址的寄存器**。 

每次执行一条指令时，程序计数器指定的地址将＋n（1字指令为＋1，2字指令为＋2）。但是，在中断指令等情况下，将存储跳转目标地址。 CPU从PC读取下一条要执行的指令所在的地址，并依次执行。

# 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用；

内存不足时抛出OutOfMemoryError或 者OutOfMemoryError：Direct buffer memory。

> 直接内存的优点：避免内核态和用户态之间反复切换，实现文件的高效存取；
>
> 在NIO之前，java.io 的方式是：
>
> ```txt
>  磁盘IO --> 直接内存[系统内核态] -->   非直接(堆)内存[用户态]  -->  直接内存[系统内核态] --> 磁盘IO
> ```
>
> 而NIO中，对文件的读写不再跟堆内存关联
>
> ```txt
>  磁盘IO --> 系统直接内存 --> 磁盘IO
> ```
>
> 非JVM管理内存，能减少GC时造成的STW（stop the world）操作。

> 直接内存的缺点：
>
> 内存管理的成本增加，由于没有自动回收机制的管理，使用不当可能造成内存溢出。
>
> 申请直接内存成本也较堆内存的申请更大。

通过参数控制直接内存分配的大小：

> -XX:MaxDirectMemorySize=<size>：指定直接内存的大小。
