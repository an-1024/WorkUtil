# JVM-类加载器的问题

考察点：类加载器的类型，以及双亲委派机制的相关点。

## 类加载器

类信息要加载到内存中是通过 JVM 的类加载器完成的。JVM 类加载器的层级分布如下：

![](/Users/azh/Dev_AZH/Java_St/JUC/jvm/src/main/resources/photo/3.类加载器双亲委派模型.png)

不同层级的加载器负责加载的类也不同。

> **启动类加载器(BootStrapClassLoader)：**最顶层的加载器，由 C++ 实现，没有父级，因此在 Java 中通常表示为 null。主要用来加载 JDK 内部的核心类库( `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。

> **扩展类加载器(ExtensionClassLoader)：**主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。

> **应用程序类加载器(AppClassLoader)：**面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

> **自定义类加载器(CustomClassLoader)：**用户自定义类加载实现类的加载，以满足特殊需求的类加载。比如有些加密的 .class 文件需要自定义类加载器对其进行解密然后再加载类。

### 加载原则

检查某个类是否已经加载：顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个Classloader已加载，就视为已加载此类，保证此类所有ClassLoader只加载一次。加载的顺序：加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

聊完 JVM 这些类加载器之后，还需要聊一下 JVM 的双亲委派委派机制。

## 双亲委派机制

> 类加载器有很多种类型，JVM 怎么知道使用那种加载器呢？通过双亲委派机制来决定。

> 双亲委派模型的工作过程是：如果一个类加载器收到了类加载器的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每一个层次的加载器 都是如此。所以，所有的类请求加载都会传送到最顶层的启动类加载器中。只有父类加载器无法完成这个加载请求(它的搜索范围中没有找到需要的类)时。子类加载器才会去尝试自己加载。

### 双亲委派的意义

1. **保证类的优先级：**Java 中的类随着它的类加载器一起具备了一种带有优先级的层级关系；
2. **保证类的唯一性：**不同的类加载器加载相同的类，这两个类的类型也是不一样的；
3. **沙箱安全机制：**防止核心 API库被随意篡改；

### 自定义类加载器的意义

双亲委派机制保证了类的唯一性，但是在实际的业务场景中，当版本进行迭代，需要兼容之前的业务，不同模块针对同一个功能类使用的版本不同，此时双亲委派保证类的唯一性反而成了弊端。因此才需要用户自己定义类加载器。

> 自定义类加载器实现方式：
>
> 1. 重写 findClass 方法；
> 2. 重写 loadClass(注意这里会打破双亲委派的机制，导致 JDK 核心类无法加载，所以需要确定子类的父类加载器是什么。)

