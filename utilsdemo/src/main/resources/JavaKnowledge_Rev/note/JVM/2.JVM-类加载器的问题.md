# JVM-类加载器的问题

考察点：类加载器的类型，以及双亲委派机制的相关点。

## 类加载器

类信息要加载到内存中是通过 JVM 的类加载器完成的。JVM 类加载器的层级分布如下：

![](/Users/azh/Dev_AZH/Java_St/JUC/jvm/src/main/resources/photo/3.类加载器双亲委派模型.png)

不同层级的加载器负责加载的类也不同。

> **启动类加载器(BootStrapClassLoader)：**最顶层的加载器，由 C++ 实现，没有父级，因此在 Java 中通常表示为 null。主要用来加载 JDK 内部的核心类库( `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。

> **扩展类加载器(ExtensionClassLoader)：**主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。

> **应用程序类加载器(AppClassLoader)：**面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

> **自定义类加载器(CustomClassLoader)：**用户自定义类加载实现类的加载，以满足特殊需求的类加载。比如有些加密的 .class 文件需要自定义类加载器对其进行解密然后再加载类。

### 加载原则

检查某个类是否已经加载：顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个Classloader已加载，就视为已加载此类，保证此类所有ClassLoader只加载一次。加载的顺序：加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

聊完 JVM 这些类加载器之后，还需要聊一下 JVM 的双亲委派委派机制。

## 双亲委派机制

> 类加载器有很多种类型，JVM 怎么知道使用那种加载器呢？通过双亲委派机制来决定。

> 双亲委派模型的工作过程是：如果一个类加载器收到了类加载器的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每一个层次的加载器 都是如此。所以，所有的类请求加载都会传送到最顶层的启动类加载器中。只有父类加载器无法完成这个加载请求(它的搜索范围中没有找到需要的类)时。子类加载器才会去尝试自己加载。

### 双亲委派的意义

1. **保证类的优先级：**Java 中的类随着它的类加载器一起具备了一种带有优先级的层级关系；
2. **保证类的唯一性：**不同的类加载器加载相同的类，这两个类的类型也是不一样的；
3. **沙箱安全机制：**防止核心 API库被随意篡改；

### 自定义类加载器的意义

双亲委派机制保证了类的唯一性，但是在实际的业务场景中，当版本进行迭代，需要兼容之前的业务，不同模块针对同一个功能类使用的版本不同，此时双亲委派保证类的唯一性反而成了弊端。因此才需要用户自己定义类加载器。

> 自定义类加载器实现方式：
>
> 1. 重写 findClass 方法；
> 2. 重写 loadClass(注意这里会打破双亲委派的机制，导致 JDK 核心类无法加载，所以需要确定子类的父类加载器是什么。)

## 堆-类加载过程

堆中，类的创建流程如图所示：

![](/Users/azh/Dev_AZH/Java_St/JUC/jvm/src/main/resources/photo/5.创建对象的主要流程.png)

### 类检查：

虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个 符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 new指令对应到语言层面上讲是， new关键词、对象克隆、对象序列化等。

### 分配内存：

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。这个步骤有两个问题:

> 1. 如何划分内存。
>
> 2. 在并发情况下，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。

> 解决办法：
>
> 1. CAS(compare and swap)：虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。
>
> 2. 本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预 先分配一小块内存。通过 `-XX:+UseTLAB`.参数来设定虚拟机是否使用TLAB(JVM会默认开`-XX:+UseTLAB`), `-XX:TLABSize` 指定TLAB大小。

### 初始化

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)， 如果使用TLAB，这一工作过程也 可以提前至TLAB分配时进行。这一 步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问 到这些字段的数据类型所对应的零值。

### 设置对象头

如图是对象头的组成：

![](/Users/azh/Dev_AZH/Java_St/JUC/jvm/src/main/resources/photo/6.对象头结构.png)

初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。

> 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域:
>
> **对象头(Header)、 实例数据(Instance Data) 和对齐填充(Padding)**。

> HotSpot虚 拟机的对象头包括两部分信息：
>
> **第一部分用于存储对象自身的运行时数据，** 如哈'希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、 偏向线程ID、偏向时间戳等。
>
> 对象头的另外一部分 是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

> 为什么要对齐填充：
>
> 1. 提高 CPU 读取效率。HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，对齐填充后可以整数倍读取，减少 I/O 操作。
> 2. 解决缓存行伪共享问题：没有对齐填充时，A线程只想要读取a，但a只占4字节，因此会连带b也会一并读取到缓存行中；而同一时刻B线程只想要读取b，但b只占4字节，因此会连带a也会一并读取到缓存行中；那么这种情况下就会存在伪共享问题，这会导致A和B线程在进行数据操作时会频繁地直接去内存获取最新值，而不是从高速缓存中获取（也就是缓存失效），导致运算速度下降。

> 为什么要压缩指针：
>
> 1. 在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据， 占用较大宽带，同时GC也会承受较大压力。
> 2. 为了减少64位平台下内存的消耗，启用指针压缩功能。
> 3. 在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的压缩编码、解码方式进行优化，使得jvm 只用32位地址就可以支持更大的内 存配置(小于等于32G)。
>
> 注意堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好。

> ### 32位最大支持4G内存，如何实现的
>
> **内存是把8个bit排成1组， 每1组成为1个单位， 大小是1byte(字节）， cpu每一次只能访问1个byte， 而不能单独去访问具体的1个小格子(bit). 1个byte字节就是内存的最小的IO单位。所以计算机的32位表示32个地址，在计算机寻址的时候，每次访问的时是一个字节，即 8 bit, 因此换算过来的话就是 2^32 \* 2^3 =4GB=2^35** 就这样算出了 2^32=4GB。
>
> 指针压缩则是将 8 个字节组成一组。

## 栈内存分配流程

栈内存分配如图所示：

![](/Users/azh/Dev_AZH/Java_St/JUC/jvm/src/main/resources/photo/8.对象内存分配.png)

