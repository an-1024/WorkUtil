# 了解 JVM 的类加载吗

思路：首先从类的加载方式聊一下，接着再介绍类的加载的生命周期。然后介绍类加载每个环节做了哪些事情。

## .class 文件加载的方式有哪些

1. 从本地加载 .class 文件：
2. 从网络上拉取 .class 文件；
3. 从 jar 包，war 包中加载 .class 文件；
4. 数据库中读取：如 JSP 从数据库中提取 .class 文件；
5. 将 Java 源文件动态编译成 .class 文件；

## 类加载的生命周期

如图所示：

![](/Users/azh/Dev_AZH/Java_St/JUC/jvm/src/main/resources/photo/2.JVM类加载机制.png)

### 加载过程

1. 首先需要通过类的完全限定名获取该类二进制字节流。
2. 获取类的字节流之后需要将类静态存储结构转换为方法区的运行时数据结构：即将就是将**类信息、常量、静态变量、即时编译器编译后的代码等数据**存放到**方法区**；所以在类加载的第二个阶段，方法区就已经有数据信息了。
3. 接着 JVM 会为这个类生成一个代表它的 java.lang.Class 对象，作为访问这个类方法区数据的入口，即将这个对象**分配到堆中**；

**需要注意这里方法区和堆中此时已经存放了哪些数据**

### 链接

链接过程分又可以细化为三个过程节点：验证、准备、解析。接下来具体介绍一下这几个过程

#### 1. 验证

验证的目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。验证主要验证四个方面：

> 文件格式验证：确认字节流符合 .class 文件规范，并且能被当前版本的虚拟机正确地处理。该阶段验证主要为保证二进制字节流能被正确地解析并存入方法区中。后面的的验证都是基于方法区的存储结构进行的。
>
> 元数据验证：对类的元数据信息进行语义校验(可以理解为对 Java 的语法校验)，保证不存在不符合 Java 语法的的元数据信息。
>
> 字节码验证：确定程序语义是合法的，并且是符合逻辑的。保证被校验类的方法在运行时不会危害JVM。
>
> 符号引用验证：符号引用验证发生在类解析阶段，是对类自身以外的信息进行匹配性校验，用来确保解析动作能正确执行。

#### 2. 准备

这个阶段是 JVM 给静态方法和静态变量赋予初值，比如static int a；给其中的a赋予初值为0，但是这里不会给final修饰的静态变量赋予初值，因为被final修饰的静态变量在编译期间就已经被赋予初值了；此外在准备阶段，JVM 只会为**类变量**分配内存，而不会为**类成员变量**分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。

**类变量**指的是被 static 修饰的变量，而其他所有类型的变量都属于**类成员变量**

#### 3.解析

主要将常量池中的符号引用替换为直接引用的过程。

> 符号引用：**符号引用即用用字符串符号的形式来表示引用，其实被引用的类、方法或者变量还没有被加载到内存中**

>  直接引用：**直接引用则是有具体引用地址的指针**

**问题来了，为什么要将符号引用转换为直接引用？**

在编译的时候一个每个 Java 类都会被编译成一个 class 文件，但在编译的时候虚拟机并不知道所引用类的地址，所以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。

这里还需要注意的是：《Java 虚拟机规范》并未规定解析阶段发生的时间，只要求了在某些特定字节码指令之前完成符号引用的解析即可。也就是说解析不一定在初始化之前，也可能在初始化之后。

### 初始化

前面几个步骤都是JVM自己完成的，直到这一步，主导权才交由程序来处理。在这个阶段期间，JVM 会根据语句执行顺序对类对象进行初始化。

### 使用

这个阶段就是在初始化之后的代码由 JVM 动态调用执行。

### 卸载

当代表一个类的 Class 对象不再被引用，那么 Class 对象的生命周期就结束了，对应的在方法区中的数据也会被卸载。