# Java 中如何定义垃圾对象

Java 不像 C、C++ 需要程序员手动的释放申请地内存空间。这个逻辑实现是在 JVM 中完成的，JVM 会帮助我们完成对象的回收，释放内存空间。那么在 JVM 如何定义垃圾对象呢？

## 引用计数法

> Java 中是通过引用来操作对象的，因此便有了引用计数的算法。当为对象添加一个引用。引用计数加1，反之减1。当 JVM 进行垃圾回收时，如果此时对象引用计数为 0 时，那么就认为这个对象是一个垃圾对象，可以被回收掉。
>
> **引用计数的优点：**
>
> 引用计数的主要优点是可以尽快地回收不再被使用的对象，同时在回收过程中不会导致长时间的停顿，还可以清晰地标明每一个对象的生存周期。
>
> 在实时应用或内存受限的系统中，实时响应能力是一项重要指标，而引用计数作为最容易实现的垃圾回收技术之一，很适合于这种情况。
>
> **引用计数的问题：**
>
> 引用计数无法解决**循环引用**问题。两个对象循环引用，但是程序中已经没有其他应用指向这两个对象，此时这两个对象应该被回收了，但是因为引用计数没有归 0，导致该对象一直存在于内存当中。

## 根可达算法

> 可达性分析算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。此时就可以将对象回收。
>
> 如何选取GCRoots对象呢？在Java语言中，可以作为GCRoots的对象包括下面几种：
>
> (1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
>
> (2). 方法区中的类静态属性引用的对象。
>
> (3). 方法区中常量引用的对象。
>
> (4). 本地方法栈中JNI(Native方法)引用的对象。
>
> 
>
> **根可达算法的优点：**
>
> 更加精确和严谨，可以分析出循环数据结构相互引用的情况；主流的编程语言Java c#的选择。
>
> **根可达算法的缺点：**
>
> > **消耗时间：**
> >
> > 从前面可达性分析知道，GC Roots主要在全局性的引用（常量或静态属性）和执行上下文中（栈帧中的本地变量表）；要在这些大量的数据中，逐个检查引用，会消耗很多时间。
>
> > **GC停顿**
> >
> > 可达性分析期间需要保证整个执行系统的一致性，对象的引用关系不能发生变化；导致GC进行时必须停顿所有Java执行线程（称为"Stop The World"）；（几乎不会发生停顿的cms收集器中，枚举根节点时也是必须要停顿的） Stop The World： 是JVM在后台自动发起和自动完成的； 在用户不可见的情况下，把用户正常的工作线程全部停掉。
>
> **HotSpot虚拟机中对象可达性分析的实现——枚举根节点**
>
> 枚举根节点也就是查找GC Roots。目前主流JVM都是准确式GC，可以直接得知哪些地方存放着对象引用，所以执行系统停顿下来后，并不需要全部、逐个检查完全局性的和执行上下文中的引用位置。
>
> 在HotSpot中，是使用一组称为OopMap的数据结构来达到这个目的的。在类加载时，计算对象内什么偏移量上是什么类型的数据；在JIT编译时，也会记录栈和寄存器中的哪些位置是引用。这样GC扫描时就可以直接得知这些信息。
>
> **安全点**
>
> HotSpot在OopMap的帮助下可以快速且准确的完成GC Roots枚举，但是这有一个问题：运行中，非常多的指令都会导致引用关系变化；如果为这些指令都生成对应的OopMap，需要的空间成本太高。
>
> 只在特定的位置记录OopMap引用关系，这些位置称为安全点（Safepoint）。即程序执行时并非所有地方都能停顿下来开始GC。
>
> **安全点的选定**
>
> 不能太少，否则GC等待时间太长；也不能太多，否则GC过于频繁，增大运行时负荷。
>
> 所以，基本上是以程序"是否具有让程序长时间执行的特征"为标准选定；"长时间执行"最明显的特征就是指令序列复用。
>
> 如：方法调用、循环跳转、循环的末尾、异常跳转等。只有具有这些功能的指令才会产生Safepoint。
>
> **如何在安全点上停顿**
>
> 对于Safepoint，如何在GC发生时让所有线程（不包括JNI线程）运行到其所在最近的Safepoint上再停顿下来？ 主要有两种方案可选：
>
> > 抢先式中断（Preemptive Suspension）
> >
> > 不需要线程主动配合，实现如下：
> >
> > 1. 在GC发生时，首先中断所有线程。
> > 2. 如果发现不在Safepoint上的线程，就恢复让其运行到Safepoint上。(现在几乎没有JVM实现采用这种方式)
>
> > 主动式中断（Voluntary Suspension）
> >
> > 1. 在GC发生时，不直接操作线程中断，而是仅简单设置一个标志。
> > 2. 让各线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。而轮询标志的地方和Safepoint是重合的。另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。
> >
> > 现在几乎所有的JVM都采用主动式中断的方式来中断线程，执行GC操作。
>
> > **程序“不执行”的时候线程如何达到安全点？**
> >
> > 如果某个线程原来就处于睡眠或者阻塞状态怎么办？如果线程原来就处于这种“不运行”的状态，那肯定不能自己主动进行中断了。让GC线程等待“不运行”的线程重新运行，然后再采用主动式中断，从时间上是不可控的。那么还有什么方法吗？JVM引入了安全区的概论。
> >
> > 
> >
> > **安全区：**
> >
> > 安全区是指在一段代码片段之中，引用关系是不变的。因此，在这个区域中任意地开始垃圾回收都是安全的。当用户线程执行到安全区里面的代码时，会首先标识自己已经进入了安全区域。如果线程要离开安全区时，需要检查是否已经完成了GC。如果完成了，线程可以继续执行，如果没有完成，线程就需要一直等待，直到收到可以离开安全区的信号为止。

## Java 常见的引用类型

java的引用类型一般分为四种:强引用、软引用、弱引用、虚引用

> 1. 强引用：普通的变量引用: `public static User user = newUser();`。
> 2. 软引用：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放 新的对象，则会把这些软引用的 对象回收掉。软引用可用来实现内存敏感的高速缓存: `public static SoftReference user = new SoftReference(newUser());`
> 3. 弱引用：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，GC会直接回收掉，很少用。
> 4. 虚引用：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用。

## finalize()方法最终判定对象是否存活

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。

再标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。

1. 第一次标记并进行一次筛选: 筛选的条件是此对象是否有必要执行finalize()方法。 当对象没有覆盖finalize方法，对象将直接被回收。
2. 第二次标记: 如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己， 只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第 二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。 注意:一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。 

# JVM 垃圾回收算法

JVM 目前实现的垃圾回收算法如图所示：

![](/Users/azh/Dev_AZH/Java_St/JUC/jvm/src/main/resources/photo/9.垃圾收集算法.png)

## 复制算法

复制算法的弊端比较明显，总有一块儿内存是空着的啥事不干，就等着将存活的对象放入，显然这中算法是不可取的。而且影响程序运行效率。

## 标记清除算法

为了解决上面内存浪费，效率低下的问题，标记清除算法先**标记对象**，然后**清除对象**，这种算法虽然没有内存浪费的情况出现，但是会带来以下两个问题：

> 1. 如果标记对象很多，效率是一个问题。
> 2. 会产生内存碎片。比如这次回收了 1K 的数据，此时需要放入 2K 数据，因为没有连续的空间，且如果以后再没有 1K 的数据，那么这块空间就永远用不上了， 这就产生了内存碎片，也会造成内存浪费。

## 标记整理算法

这个算法解决了标记清除算法中内存碎片的问题，与标记清除算法前面两个阶段一样，都需要标记清除。在清除之前，需要移动对象到另一端(可以理解为整理对象)，然后以这个端为边界，清除所有垃圾对象。但是这种算法同样存在效率问题，大对象的来回移动会造成效率低下。

## 分代收集算法

分代垃圾收集算法是根据分代区域的不同，使用不同的垃圾算法进行垃圾回收。

